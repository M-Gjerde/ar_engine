#version 450

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Pixel {
    vec4 val;
};

layout(set = 0, binding = 0) readonly buffer  imageOne {
    vec4 imgData[];
}imgOne;

layout(set = 0, binding = 1) readonly buffer imageTwo {
    vec4 imgData[];
} imgTwo;

layout(set = 1, binding = 0) buffer imageOut {
    vec4 imgData[];
} imgOut;


void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (!(index > (640 * 5)))
     return;
    int stride = 640;
    uint disparityLevel = 128;

    // If we are closing in on last columns then decrease disparity level.
    // disp 128 then 512
    // disp 256 then 384
    uint col = index % stride;
    if (col <= disparityLevel){
        disparityLevel -= (disparityLevel - col);
    }
    float sum = 0;
    float kernelSize = 25;
    float minAverage = 255;
    float minSum = 255;
    float pixelDisparity = 0;

    int lowLimit = 2, highLimit = 3;
    const int k = 5;
    float matchKernel[k][k];
    // Read left image pixel
    int rowLoop = 0, colLoop = 0;
    for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
        for (int col = -lowLimit; col < highLimit; ++col){
            matchKernel[rowLoop][colLoop] = imgOne.imgData[index + row + col].x;
            colLoop++;
        }
        rowLoop++;
    }

    float rightImgKernel[k][k];
    // Match this pixel to the right image
    for (uint d = disparityLevel; d > 0; --d){
        sum = 0;
        rowLoop = 0;
        colLoop = 0;
        for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
            for (int col = -lowLimit; col < highLimit; ++col){
                rightImgKernel[rowLoop][colLoop] = imgTwo.imgData[index + row + col - d].x;
                colLoop++;
            }
            rowLoop++;
        }

        for (int i = 0; i < k; ++i){
            for (int j = 0; j < k; ++j){
                sum += abs(matchKernel[i][j] - rightImgKernel[i][j]);
            }
        }
        if (sum < minSum){
            minSum = sum;
            pixelDisparity = d;
        }
    }
    imgOut.imgData[index].x = pixelDisparity;//.val.x = pixelDisparity;
}