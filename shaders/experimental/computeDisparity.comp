#version 450
#extension GL_EXT_debug_printf : enable

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Pixel {
    vec4 val;
};

layout(set = 0, binding = 0) readonly buffer  imageOne {
    vec4 imgData[];
}imgOne;

layout(set = 0, binding = 1) readonly buffer imageTwo {
    vec4 imgData[];
} imgTwo;

layout(set = 1, binding = 0) buffer imageOut {
    vec4 imgData[];
} imgOut;


void main()
{

    uint index = gl_GlobalInvocationID.x;
    if (!(index > (640 * 5))){
        return;

    }
    int stride = 640;
    uint disparityLevel = 128;
    uint row = index / stride;
    // If we are closing in on last columns then decrease disparity level.
    // disp 128 then 512
    // disp 256 then 384
    uint col = index % stride;

    if (col <= disparityLevel){
        disparityLevel -= (disparityLevel - col);
    }
    float sum = 0;
    float minAverage = 255;
    float minSum = 255;
    float pixelDisparity = 0;
    float prevSum = 0;

    float disparities[128];
    int foundDisparities = 0;
    uint minIndex = 0;

    float kernelSize = 361;
    int lowLimit = 9, highLimit = 10;
    const int k = 19;
    float matchKernel[k][k];
    // Read left image pixel
    int rowLoop = 0, colLoop = 0;
    for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
        for (int col = -lowLimit; col < highLimit; ++col){
            matchKernel[rowLoop][colLoop] = imgOne.imgData[index + row + col].x;
            colLoop++;
        }
        rowLoop++;
    }

    float rightImgKernel[k][k];
    // Match this pixel to the right image
    for (uint d = disparityLevel; d > 0; --d){
        sum = 0;
        rowLoop = 0;
        colLoop = 0;
        for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
            for (int col = -lowLimit; col < highLimit; ++col){
                rightImgKernel[rowLoop][colLoop] = imgTwo.imgData[index + row + col - d].x;
                colLoop++;
            }
            rowLoop++;
        }

        for (int i = 0; i < k; ++i){
            for (int j = 0; j < k; ++j){
                sum += abs(matchKernel[i][j] - rightImgKernel[i][j]);
            }
        }
        sum = sum / kernelSize;
        disparities[d] = sum;


        if (sum <= minSum){
            minSum = sum;
            pixelDisparity = d;

            // If we got identical minimizers then discard
            if (prevSum == sum)
            pixelDisparity = 0;
            else
            minIndex = d;

            prevSum = sum;

        }
    }



    // Determine a 10% threshold for the minimium value. If there are more than another minimizer below this threshold then discard value
    float threshold = (10 * disparities[minIndex] / 100) + disparities[minIndex];
    int minimizers = 0;
    for (int i = 0; i < disparityLevel; ++i){
        // Find the amount of minimizers below threshold
        if (disparities[i] < threshold){
            minimizers++;
        }
    }

    // If there are more than 2 minimziers then discard pixel
    if (minimizers > 2){
        imgOut.imgData[index].x = 0;

    } else
    imgOut.imgData[index].x = pixelDisparity;

    //imgOut.imgData[index].x = pixelDisparity;


}