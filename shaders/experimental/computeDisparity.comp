#version 450

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Pixel {
    vec4 val;
};

layout(set = 0, binding = 0) readonly buffer  imageOne {
    vec4 imgData[];
}imgOne;

layout(set = 0, binding = 1) readonly buffer imageTwo {
    vec4 imgData[];
} imgTwo;

layout(set = 1, binding = 0) buffer imageOut {
    vec4 imgData[];
} imgOut;


void main()
{
    uint index = gl_GlobalInvocationID.x;

    float sum = 0;
    float kernelSize = 49;
    float minAverage = 255;
    float minSum = 21000;
    float pixelDisparity = 0;
    uint disparityLevel = 128;
    int lowLimit = 3, highLimit = 4;
    int stride = 640;

    // If we are closing in on last columns then decrease disparity level.
    // disp 128 then 512
    // disp 256 then 384
    uint col = index % stride;
    if (col >= 512){
        disparityLevel = disparityLevel - (col - 512);
    }

    float readPosLeft = 0, readPosRight = 0;
    float sumLeft = 0;
    float sumRight = 0;
    // Read left image pixel
    for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
        for (int col = -lowLimit; col < highLimit; ++col){
            readPosRight = imgTwo.imgData[index + row + col].x;
            sumRight += readPosRight;
        }
    }

    // Match this pixel to the right image
    for (int d = lowLimit; d < disparityLevel; ++d){
        sumLeft = 0;
        for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
            for (int col = -lowLimit; col < highLimit; ++col){
                readPosLeft = imgOne.imgData[index + row + d  + col].x;
                sumLeft += readPosLeft;
            }
        }
        sum = abs(sumRight - sumLeft);
        if (sum < minSum){
            minSum = sum;
            pixelDisparity = d;
        }
    }
    imgOut.imgData[index].x = pixelDisparity;//.val.x = pixelDisparity;
}