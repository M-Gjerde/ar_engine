#version 450
#extension GL_EXT_debug_printf : enable

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Pixel {
    vec4 val;
};

layout(set = 0, binding = 0) readonly buffer  imageOne {
    vec4 imgData[];
}imgOne;

layout(set = 0, binding = 1) readonly buffer imageTwo {
    vec4 imgData[];
} imgTwo;

layout(set = 1, binding = 0) buffer imageOut {
    vec4 imgData[];
} imgOut;


void main()
{
    uint index = gl_GlobalInvocationID.x;

    float roww = index / 640;
    if (index < (640 * 10))
    return;

    const int disparityLevel = 256;
    const int dispArraySize = 256;
    int stride = 640;
    int lowBound = -2;
    int highBound = 3;
    const int kernelSize = 25;
    // Left image kernel
    float leftImgValues[kernelSize];
    int leftImgIndex = 0;
    for (int row = stride * lowBound; row < stride * highBound; row+=stride){
        for (int col = lowBound; col < highBound; ++col){
            leftImgValues[leftImgIndex] = imgOne.imgData[index + row + col].x;

            //debugPrintfEXT("LImg: %f i: %d\n", leftImgValues[leftImgIndex], leftImgIndex);
            //debugPrintfEXT("index: %d, row: %d, col: %d, imgOne: %f\n", index, row, col, imgOne.imgData[index + row + col].x);
            leftImgIndex++;

        }
    }


    bool firstRun = true;
    float SAD[disparityLevel];
    int disparity = 0;
    float temp = 100;
    for (int d = 0; d < disparityLevel; ++d){
        // Right image Kernel
        float rightImgValues[kernelSize];
        int rightImgIndex = 0;
        for (int row = stride * lowBound; row < stride * highBound; row+=stride){
            for (int col = lowBound; col < highBound; ++col){
                rightImgValues[rightImgIndex] = imgTwo.imgData[index + row + col - d].x;

                rightImgIndex++;
            }
        }

        // Calculate the SAD for this disparity level.
        float sum = 0;
        for (int i = 0; i < kernelSize; ++i){
            sum += abs(leftImgValues[i] - rightImgValues[i]);
        }
        // save all the SAD values
        SAD[d] = sum;

        // determine the minimum sad value
        if (temp > SAD[d]) {
            temp=SAD[d];
            disparity = d;
        }
    }

    // Save minimum value to outImage
    imgOut.imgData[index].x = disparity;
    //if (index == (640 * 240 + 320))
        //debugPrintfEXT("disparity: %d\n", disparity);




    /*
    if (!(index > (640 * 5))){
        return;

    }
    int stride = 640;
    uint disparityLevel = 128;
    uint row = index / stride;
    // If we are closing in on last columns then decrease disparity level.
    // disp 128 then 512
    // disp 256 then 384
    uint col = index % stride;

    if (col <= disparityLevel){
        disparityLevel -= (disparityLevel - col);
    }
    float sum = 0;
    float minAverage = 255;
    float minSum = 255;
    float pixelDisparity = 0;
    float prevSum = 0;

    float disparities[128];
    int foundDisparities = 0;
    uint minIndex = 0;

    float kernelSize = 81;
    int lowLimit = 4, highLimit = 5;
    const int k = 9;
    float matchKernel[k][k];
    // Read left image pixel
    int rowLoop = 0, colLoop = 0;
    for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
        for (int col = -lowLimit; col < highLimit; ++col){
            matchKernel[rowLoop][colLoop] = imgOne.imgData[index + row + col].x;
            colLoop++;
        }
        rowLoop++;
    }

    float rightImgKernel[k][k];
    // Match this pixel to the right image
    for (uint d = disparityLevel; d > 0; --d){
        sum = 0;
        rowLoop = 0;
        colLoop = 0;
        for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
            for (int col = -lowLimit; col < highLimit; ++col){
                rightImgKernel[rowLoop][colLoop] = imgTwo.imgData[index + row + col - d].x;
                colLoop++;
            }
            rowLoop++;
        }

        for (int i = 0; i < k; ++i){
            for (int j = 0; j < k; ++j){
                sum += abs(matchKernel[i][j] - rightImgKernel[i][j]);
            }
        }
        sum = sum / kernelSize;
        disparities[d] = sum;


        if (sum <= minSum){
            minSum = sum;
            pixelDisparity = d;

            // If we got identical minimizers then discard
            if (prevSum == sum)
            pixelDisparity = 0;
            else
            minIndex = d;

            prevSum = sum;

        }
    }

    // Determine a 10% threshold for the minimium value. If there are more than another minimizer below this threshold then discard value
    float threshold = (5 * disparities[minIndex] / 100) + disparities[minIndex];
    int minimizers = 0;
    for (int i = 0; i < disparityLevel; ++i){
        // Find the amount of minimizers below threshold
        if (disparities[i] < threshold){
            minimizers++;
        }
    }

    // If there are more than 2 minimziers then discard pixel
    if (minimizers > 2){
        imgOut.imgData[index].x = 0;

    } else

    */

}