#version 450

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Pixel {
    vec4 val;
};

layout(set = 0, binding = 0) readonly buffer  imageOne {
    vec4 imgData[];
}imgOne;

layout(set = 0, binding = 1) readonly buffer imageTwo {
    vec4 imgData[];
} imgTwo;

layout(set = 1, binding = 0) buffer imageOut {
    vec4 imgData[];
} imgOut;


void main()
{
    uint index = gl_GlobalInvocationID.x;

    float sum = 0;
    float kernelSize = 9;
    float minAverage = 255;
    float pixelDisparity = 0;
    int disparityLevel = 64;
    float readPosLeft = 0, readPosRight = 0;

    int lowLimit = 1, highLimit = 2;
    int stride = 1280;

    if (!(index > stride && index < 921600 - disparityLevel)) return;
    // Disparity level. Match this pixel
    for (int d = 0; d < disparityLevel; ++d){
        // kernel
        for (int row = -stride * lowLimit; row < stride * highLimit; row+=stride){
            for (int col = -lowLimit; col < highLimit; ++col){
                readPosRight = imgOne.imgData[index + row + d + col].x;//.val.x;
                readPosLeft = imgTwo.imgData[index + row + col].x;//.val.x;

                sum += abs(readPosRight - readPosLeft);
            }
        }

        float average = sum / kernelSize;
        if (average < minAverage){
            minAverage = average;
            pixelDisparity = d;

        }
        sum = 0;
    }
    imgOut.imgData[index].x = pixelDisparity;//.val.x = pixelDisparity;
    pixelDisparity = 0;
    minAverage = 100;// Reset min for avg

}