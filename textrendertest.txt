void VulkanRenderer::textRenderTest() {
    /*
    const uint32_t fontWidth = STB_FONT_consolas_24_latin1_BITMAP_WIDTH;
    const uint32_t fontHeight = STB_FONT_consolas_24_latin1_BITMAP_WIDTH;

    static unsigned char font24pixels[fontWidth][fontHeight];
    stb_font_consolas_24_latin1(stbFontData, font24pixels, fontHeight);

    dataBuffer.bufferSize = 2048 * sizeof(glm::vec4);
    dataBuffer.bufferUsage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    dataBuffer.bufferProperties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    dataBuffer.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    buffer->createBuffer(&dataBuffer);


    images->createImage(fontWidth, fontHeight, VK_FORMAT_R8_UNORM, VK_IMAGE_TILING_OPTIMAL,
                        VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
                        VK_IMAGE_LAYOUT_UNDEFINED,
                        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, image, imageMemory, &memoryRequirements);


    // Staging
    ArBuffer stagingBuffer{};
    stagingBuffer.bufferSize = memoryRequirements.size;
    stagingBuffer.bufferUsage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    stagingBuffer.bufferProperties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
    stagingBuffer.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

    buffer->createBuffer(&stagingBuffer);
    uint8_t *data;
    vkMapMemory(arEngine.mainDevice.device, stagingBuffer.bufferMemory, 0, stagingBuffer.bufferSize, 0,
                (void **) &data);
    memcpy(data, &font24pixels[0][0], fontWidth * fontHeight);
    vkUnmapMemory(arEngine.mainDevice.device, stagingBuffer.bufferMemory);

    // Transition image to transfer destination
    images->transitionImageLayout(image, VK_IMAGE_LAYOUT_UNDEFINED,
                                  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, arEngine.commandPool, arEngine.graphicsQueue);

    // Copy buffer to image
    images->copyBufferToImage(stagingBuffer.buffer, image, fontWidth, fontHeight, arEngine.commandPool,
                              arEngine.graphicsQueue);


    // Transition image to shader read
    images->transitionImageLayout(image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                                  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, arEngine.commandPool,
                                  arEngine.graphicsQueue);

    // Create image view
    images->createImageView(image, VK_FORMAT_R8_UNORM, VK_IMAGE_ASPECT_COLOR_BIT, &imageView);


    // Create sampler
    VkSamplerCreateInfo samplerInfo{};
    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    samplerInfo.magFilter = VK_FILTER_LINEAR;
    samplerInfo.minFilter = VK_FILTER_LINEAR;
    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;

    samplerInfo.anisotropyEnable = VK_FALSE;
    samplerInfo.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;

    samplerInfo.unnormalizedCoordinates = VK_FALSE;
    samplerInfo.compareEnable = VK_FALSE;
    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    samplerInfo.mipLodBias = 0.0f;
    samplerInfo.minLod = 0.0f;
    samplerInfo.maxLod = 0.0f;
    if (vkCreateSampler(arEngine.mainDevice.device, &samplerInfo, nullptr, &sampler) !=
        VK_SUCCESS) {
        throw std::runtime_error("failed to create texture sampler!");
    }
    // Create descriptor
    // Font uses a separate descriptor pool
    descriptorInfo.descriptorPoolCount = 1;
    descriptorInfo.descriptorCount = 1;
    descriptorInfo.descriptorSetLayoutCount = 1;
    descriptorInfo.descriptorSetCount = 1;
    std::vector<uint32_t> descriptorCounts;
    descriptorCounts.push_back(1);
    descriptorInfo.pDescriptorSplitCount = descriptorCounts.data();
    std::vector<uint32_t> bindings;
    bindings.push_back(0);
    descriptorInfo.pBindings = bindings.data();
    // types
    std::vector<VkDescriptorType> types(1);
    types[0] = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorInfo.pDescriptorType = types.data();
    // stages
    std::array<VkShaderStageFlags, 1> stageFlags = {VK_SHADER_STAGE_FRAGMENT_BIT};
    descriptorInfo.stageFlags = stageFlags.data();

    descriptorInfo.sampler = sampler;
    descriptorInfo.view = imageView;

    descriptors->createDescriptors(descriptorInfo, &descriptor);

    // Pipeline cache
    VkPipelineCacheCreateInfo pipelineCacheCreateInfo = {};
    pipelineCacheCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    vkCreatePipelineCache(arEngine.mainDevice.device, &pipelineCacheCreateInfo, nullptr, &pipelineCache);


    /// --- RENDER PASS ---
    // Color attachment
    VkAttachmentDescription colorAttachment{};
    colorAttachment.format = arEngine.swapchainFormat;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_LOAD;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

    // Setup to how the colorAttachment is referenced by shader
    VkAttachmentReference colorAttachmentRef{};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

    // depth attachment
    VkAttachmentDescription depthAttachment{};
    depthAttachment.format = images->findDepthFormat();
    depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
    depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
    depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    VkAttachmentReference depthAttachmentRef{};
    depthAttachmentRef.attachment = 1;
    depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;

    std::array<VkAttachmentDescription, 2> attachmentDescriptions = {colorAttachment, depthAttachment};

    VkSubpassDependency subpassDependencies[2] = {};

    // Transition from final to initial (VK_SUBPASS_EXTERNAL refers to all commands executed outside of the actual renderpass)
    subpassDependencies[0].srcSubpass = VK_SUBPASS_EXTERNAL;
    subpassDependencies[0].dstSubpass = 0;
    subpassDependencies[0].srcStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
    subpassDependencies[0].dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    subpassDependencies[0].srcAccessMask = VK_ACCESS_MEMORY_READ_BIT;
    subpassDependencies[0].dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
    subpassDependencies[0].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;

    // Transition from initial to final
    subpassDependencies[1].srcSubpass = 0;
    subpassDependencies[1].dstSubpass = VK_SUBPASS_EXTERNAL;
    subpassDependencies[1].srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    subpassDependencies[1].dstStageMask = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
    subpassDependencies[1].srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
    subpassDependencies[1].dstAccessMask = VK_ACCESS_MEMORY_READ_BIT;
    subpassDependencies[1].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;

    VkSubpassDescription subpassDescription = {};
    subpassDescription.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpassDescription.flags = 0;
    subpassDescription.inputAttachmentCount = 0;
    subpassDescription.pInputAttachments = nullptr;
    subpassDescription.colorAttachmentCount = 1;
    subpassDescription.pColorAttachments = &colorAttachmentRef;
    subpassDescription.pResolveAttachments = nullptr;
    subpassDescription.pDepthStencilAttachment = &depthAttachmentRef;
    subpassDescription.preserveAttachmentCount = 0;
    subpassDescription.pPreserveAttachments = nullptr;

    VkRenderPassCreateInfo renderPassInfo = {};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.pNext = nullptr;
    renderPassInfo.attachmentCount = 2;
    renderPassInfo.pAttachments = attachmentDescriptions.data();
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpassDescription;
    renderPassInfo.dependencyCount = 2;
    renderPassInfo.pDependencies = subpassDependencies;

    vkCreateRenderPass(arEngine.mainDevice.device, &renderPassInfo, nullptr, &textRenderPass);



    // Create PIPELINE
    ArShadersPath shadersPath{};
    shadersPath.vertexShader = "../shaders/textoverlay/textVert";
    shadersPath.fragmentShader = "../shaders/textoverlay/textFrag";

    textPipeline.device = arEngine.mainDevice.device;
    textPipeline.swapchainImageFormat = arEngine.swapchainFormat;
    textPipeline.swapchainExtent = arEngine.swapchainExtent;
    pipeline.textRenderPipeline(textRenderPass, descriptor, shadersPath, &textPipeline, pipelineCache);


    mapped = nullptr;
    vkMapMemory(arEngine.mainDevice.device, dataBuffer.bufferMemory, 0, VK_WHOLE_SIZE, 0, (void **) &mapped);


    addText("Magnus - Vulkan Text render test", 640.0f, 360.0f, alignCenter);

    //vkUnmapMemory(arEngine.device.device, dataBuffer.bufferMemory);
    updateCommandBuffers();
     */
}

// Add text to the current buffer
// todo : drop shadow? color attribute?
void VulkanRenderer::addText(const std::string &text, float x, float y, TextAlign align) {
    /*
    numLetters = 0;

    const uint32_t firstChar = STB_FONT_consolas_24_latin1_FIRST_CHAR;
    assert(mapped != nullptr);

    const float charW = 1.5f / (float) viewport.WIDTH;
    const float charH = 1.5f / (float) viewport.HEIGHT;

    float fbW = (float) viewport.WIDTH;
    float fbH = (float) viewport.HEIGHT;
    x = (x / fbW * 2.0f) - 1.0f;
    y = (y / fbH * 2.0f) - 1.0f;

    // Calculate text width
    float textWidth = 0;
    for (auto letter : text) {
        stb_fontchar *charData = &stbFontData[(uint32_t) letter - firstChar];
        textWidth += charData->advance * charW;
    }

    switch (align) {
        case alignRight:
            x -= textWidth;
            break;
        case alignCenter:
            x -= textWidth / 2.0f;
            break;
    }

    // Generate a uv mapped quad per char in the new text
    for (auto letter : text) {
        stb_fontchar *charData = &stbFontData[(uint32_t) letter - firstChar];

        mapped->x = (x + (float) charData->x0 * charW);
        mapped->y = (y + (float) charData->y0 * charH);
        mapped->z = charData->s0;
        mapped->w = charData->t0;
        std::cout << mapped->x << " " << mapped->y << std::endl;
        mapped++;

        mapped->x = (x + (float) charData->x1 * charW);
        mapped->y = (y + (float) charData->y0 * charH);
        mapped->z = charData->s1;
        mapped->w = charData->t0;
        std::cout << mapped->x << " " << mapped->y << std::endl;
        mapped++;

        mapped->x = (x + (float) charData->x0 * charW);
        mapped->y = (y + (float) charData->y1 * charH);
        mapped->z = charData->s0;
        mapped->w = charData->t1;
        std::cout << mapped->x << " " << mapped->y << std::endl;
        mapped++;

        mapped->x = (x + (float) charData->x1 * charW);
        mapped->y = (y + (float) charData->y1 * charH);
        mapped->z = charData->s1;
        mapped->w = charData->t1;
        std::cout << mapped->x << " " << mapped->y << "\n" << std::endl;
        mapped++;

        x += charData->advance * charW;

        numLetters++;
    }
*/

}

void VulkanRenderer::updateCommandBuffers() {
/*
    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

    VkClearValue clearValues[2];
    clearValues[1].color = {{0.0f, 0.0f, 0.0f, 0.0f}};

    VkRenderPassBeginInfo renderPassBeginInfo{};
    renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    renderPassBeginInfo.renderPass = textRenderPass;
    renderPassBeginInfo.renderArea.extent.width = viewport.WIDTH;
    renderPassBeginInfo.renderArea.extent.height = viewport.HEIGHT;
    renderPassBeginInfo.clearValueCount = 2;
    renderPassBeginInfo.pClearValues = clearValues;

    for (int32_t i = 0; i < cmdBuffersText.size(); ++i) {
        renderPassBeginInfo.framebuffer = swapChainFramebuffers[i];

        vkBeginCommandBuffer(cmdBuffersText[i], &beginInfo);

        vkCmdBeginRenderPass(cmdBuffersText[i], &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);

        vkCmdBindPipeline(cmdBuffersText[i], VK_PIPELINE_BIND_POINT_GRAPHICS, textPipeline.pipeline);
        vkCmdBindDescriptorSets(cmdBuffersText[i], VK_PIPELINE_BIND_POINT_GRAPHICS, textPipeline.pipelineLayout, 0, 1,
                                &descriptor.descriptorSets[0], 0,
                                NULL);

        VkDeviceSize offsets = 0;
        vkCmdBindVertexBuffers(cmdBuffersText[i], 0, 1, &dataBuffer.buffer, &offsets);
        vkCmdBindVertexBuffers(cmdBuffersText[i], 1, 1, &dataBuffer.buffer, &offsets);
        for (uint32_t j = 0; j < numLetters; j++) {
            vkCmdDraw(cmdBuffersText[i], 4, 1, j * 4, 0);
        }


        vkCmdEndRenderPass(cmdBuffersText[i]);
        vkEndCommandBuffer(cmdBuffersText[i]);
    }
    */
    visible = true;
}

    void textRenderTest();

    enum TextAlign { alignLeft, alignCenter, alignRight };

        /*
            // TextRendering

            VkImageView imageView{};
            VkSampler sampler{};
            ArDescriptorInfo descriptorInfo{};
            ArDescriptor descriptor;
            VkImage image{};
            VkDeviceMemory imageMemory{};
            VkMemoryRequirements memoryRequirements{};
            glm::vec4 *mapped = nullptr;
            uint32_t numLetters{};
            stb_fontchar stbFontData[STB_FONT_consolas_24_latin1_NUM_CHARS]{};
            ArBuffer dataBuffer{};
            std::vector<VkCommandBuffer> cmdBuffersText;
            ArPipeline textPipeline{};
            VkPipelineCache pipelineCache{};
             */